import { AppDataSource } from "../data-source";
import { Student } from "../entities/Student";
import { School } from "../entities/Schools";

type StudentJsonRow = {
  SNO: number;
  mandal: string;
  SCHOOL: string; // school_id (UUID)
  fullName: string;
  surName: string;
  gender?: "BOY" | "GIRL" | "OTHER";
  email?: string;
  phoneNumber?: string;
};


export class StudentService {
  private studentRepo = AppDataSource.getRepository(Student);
  private schoolRepo = AppDataSource.getRepository(School);

  async registerStudent(data: {
    fullName: string;
    email?: string;
    schoolId: string;
    surName: string;
    phoneNumber?: string

  }) {
    const school = await this.schoolRepo.findOne({
      where: { id: data.schoolId, is_active: true },
    });

    if (!school) {
      throw new Error("School not authorized");
    }

    const student = this.studentRepo.create({
      fullName: data.fullName,
      email: data.email,
      school,
      surName: data.surName,
      phoneNumber: data.phoneNumber

    });

    return this.studentRepo.save(student);
  }

  async bulkStudentInsert(data:[{
    fullName: string;
    email?: string;
    surName: string;
    phoneNumber?: string
  }],params:any)
  {
    const { schoolId } = params;

  if (!schoolId || !Array.isArray(data)) {
      throw new Error("school and students array are required");
  }

  const school = await this.schoolRepo.findOne({
    where: { id: schoolId, is_active: true }
  });

  if (!school) {
    throw new Error("Invalid school");
  }

  const entities: Student[] = [];

  for (const row of data) {
    if (!row.fullName || !row.surName) continue;

    const student = this.studentRepo.create({
      fullName: row.fullName,
      surName: row.surName,
      email: row.email || null,
      phoneNumber: row.phoneNumber || null,
      school
    });

    entities.push(student);
  }

    const saved = await this.studentRepo.save(entities);

    return {
      message: "Students inserted successfully",
      count: saved.length
    }
  }




async insertStudentByJson(data: StudentJsonRow[]) {
  if (!Array.isArray(data) || data.length === 0) {
    throw new Error("Invalid or empty input data");
  }

  const students: Student[] = [];
  const schoolCache = new Map<string, School>();

  for (const row of data) {
    // ðŸ”¹ Basic validation
    if (!row.SCHOOL || !row.fullName || !row.surName) {
      continue; // skip invalid rows safely
    }

    // ðŸ”¹ Resolve school (cached)
    let school = schoolCache.get(row.SCHOOL);

    if (!school) {
      const found = await this.schoolRepo.findOne({
        where: { id: row.SCHOOL, is_active: true },
      });

      if (!found) {
        throw new Error(`Invalid school ID: ${row.SCHOOL}`);
      }

      school = found;
      schoolCache.set(row.SCHOOL, school);
    }

    // ðŸ”¹ Normalize gender safely (DB enum = BOY | GIRL). "GIRL" BOY
    const gender: "BOY" | "GIRL" =
      row.gender === "GIRL" ? "GIRL" : "BOY";  

    const student = this.studentRepo.create({
      fullName: row.fullName.trim(),
      surName: row.surName.trim(),
      gender,
      email: row.email?.trim() || null,
      phoneNumber: row.phoneNumber?.trim() || null,
      school,
      // loginNumber â†’ auto-generated by @BeforeInsert
    });

    students.push(student);
  }

  if (students.length === 0) {
    return {
      message: "No valid students to insert",
      count: 0,
    };
  }

  // ðŸ”¥ Transaction-safe bulk insert
  const saved = await this.studentRepo.manager.transaction(async (manager) => {
    return manager.save(Student, students);
  });

  return {
    message: "Students inserted successfully",
    count: saved.length,
  };
}



  async getAllStudents()
  {
     return await this.studentRepo.find({
    relations: ["school"],
    order: { surName: "ASC" }
  });
  }

  async getStudentCounts()
  {
    
      const count = await this.studentRepo.count();

      const result = await AppDataSource.query(`
    SELECT 
      s.id AS "schoolId",
      s.name AS "schoolName",
      s.code as "schoolCode",
      s.address as "schoolAddress",
      COUNT(st.id) AS "studentCount"
    FROM schools s
    LEFT JOIN students st ON st.school_id = s.id
    GROUP BY s.id, s.name
    ORDER BY s.name
  `);
      return {
        total_count:count,
        school_wise_counts:result
      }
    
    //   res.json({ totalStudents: count });
    
  }

  async getStudentsBySchoolId(schoolId:string)
  {
    const school = await this.schoolRepo.findOne({
      where: { id: schoolId, is_active: true },
    });

    if (!school) {
      throw new Error("School not authorized");
    }

  const students = await this.studentRepo.find({
    where: { school: { id: schoolId } },
    relations: ["school"],
    order: { surName: "ASC" }
  });
  return {students,school};
  

  }


  async getStudentsByHallTicketId(studentId:string)
  {
  return await this.studentRepo.findOne({
    where: { loginNumber: studentId  },
    relations: ["school"]
  });

  }

  async generateRollNumbers() {
  const ROLL_START = 250001;

  // ðŸ”¹ Fetch students sorted by surname + fullname
  const students = await this.studentRepo.find({
    // where: {
    //   school: { id: schoolId },
    // },
    relations: ["school"],
    order: {
      surName: "ASC",
      fullName: "ASC",
    },
  });

  if (students.length === 0) {
    throw new Error("No students found for this school");
  }

  // ðŸ”’ Prevent re-generation
  if (students.some(s => s.rollNumber !== null)) {
    throw new Error("Roll numbers already generated for this school");
  }

  // ðŸ”¹ Assign roll numbers starting from 250001
  students.forEach((student, index) => {
    student.rollNumber = ROLL_START + index;
  });

  // ðŸ”¹ Save safely in a transaction
  await this.studentRepo.manager.transaction(async (manager) => {
    await manager.save(Student, students);
  });

  return {
    message: "Roll numbers generated successfully",
    startFrom: ROLL_START,
    total: students.length,
  };
  }
  
}
